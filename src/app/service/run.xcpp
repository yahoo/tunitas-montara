// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc, 2021.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-montara/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/montara/tree/LICENSE
#divert <fpp>
#import tunitas.montara.endpoint
#import tunitas.string.literals
#import tunitas.montara.storage
#import format // [[REMOVEWHEN]] langu::age::quote exists in module-langu >= 0.1.0 or so
// #import langu.age.quote // later for langu::age::quote::q
#import sys.exits.constants
#import sys.posix
namespace app::service {
  namespace [[eponymous]] packaging_run {
    namespace [[implementation]] implementation {
      using namespace tunitas::string::literals;
      namespace endpoint = tunitas::montara::endpoint;
      namespace storage = tunitas::montara::storage;
      using namespace format;
      // using namespace langu::age::quote;
      using namespace sys::exits::constants;
      using namespace sys::posix;
      namespace [[interface]] interface { }
    }
  }
}
#endiv
#divert <hpp>
#import app.service.Configuration
namespace app::service {
  namespace packaging_run::implementation {
    //
    // Run the service
    // There is no termination (except by SIGTERM)
    //
    // Usage:
    //
    //   Configuration cfg{...};
    //   Specification specification{...};
    //   auto parser = Parser{cfg, specification};
    //   auto parsed = parser.parse(Args{c, v});
    //   if (ok(parsed)) {
    //     throw Quitting{cfg.NAME};
    //   }
    //   run(cfg);
    //   return sys::exits::OK;
    //
    namespace interface {
      auto run(Configuration const &) -> void;
    }
  }
  using packaging_run::implementation::interface::run;
}
#endiv
#divert <cpp>
#import app.exception.Quitting
#import app.service.constants
#import app.service.defaults
#import app.service.Pidfile
#import format.q
// #import langu.age.quote.q
#import microhttpd.ip.format
#import microhttpd.sys.drop_privileges
#import microhttpd.Service
#import microhttpd.service.Specification
#import std.boolalpha
#import std.cout
#import std.cerr
#import std.exception
#import std.make_shared
#import tunitas.app.exception.Aspect
#import tunitas.montara.endpoint.Consent
#import tunitas.montara.endpoint.Consent_CreateWithArray
#import tunitas.montara.endpoint.Consent_CreateWithList
#import tunitas.montara.endpoint.Consent_FindIdentifiersByEntity
#import tunitas.montara.endpoint.Consent_Identifier
#import tunitas.montara.endpoint.Consent_RevokeWithArray
#import tunitas.montara.endpoint.Consent_RevokeWithList
#import tunitas.montara.endpoint.Consent_Revoke_Identifier
#import tunitas.montara.endpoint.Transfer
#import tunitas.montara.endpoint.Transfer_CreateWithArray
#import tunitas.montara.endpoint.Transfer_CreateWithList
#import tunitas.montara.endpoint.Transfer_FindByConsentIdentifier
#import tunitas.montara.endpoint.Transfer_Identifier
#import tunitas.montara.endpoint.Subscription
#import tunitas.montara.endpoint.Subscription_FindByEntity
#import tunitas.montara.endpoint.Subscription_Identifier
#import tunitas.montara.storage.factory
#import tunitas.montara.storage.Configuration
#import sys.posix.daemon
#import sys.posix.signal
#import sys.posix.SIG
namespace app::service::packaging_run::implementation {
  auto interface::run(Configuration const &cfg) -> void {
    signal(SIG::PIPE, SIG::IGNORE); // not checking the return code ... hope it worked
    //
    auto service = [&cfg]() {
                     auto specification = microhttpd::service::Specification{};
                     using namespace constants::server;
                     auto with_port = cfg.port.value_or(defaults::SERVICE_PORT);
                     debug(cfg) << "port=" << microhttpd::ip::format(with_port) << '\n';
                     specification.set_debug(Switch::ON);
                     specification.set_use_ipv4(Switch::ON).set_use_ipv6(Switch::ON); // this is already the default
#if 0
                     specification.set_concurrency(METHOD);
                     // WATCHOUT - thread-per-connection and max-threads conflict and the server will be unstartable
                     // specification.set_max_threads(THREADS);
#endif
                     specification.set_regex_checking(Switch::ON);
                     specification.set_port(with_port);
                     return microhttpd::Service{move(specification)};
                   }();
    if (cfg.drop_privileges.value_or(defaults::DROP_PRIVILEGES)) {
#warning [[FIXTHIS]] when implemented, convert to the use of the two-argument microhttpd::sys::drop privileges(user, group)
      auto const UNIMPLEMENTED_TWO_ARGUMENT_DROP_PRIVILEGES_USER_GROUP = true;
      auto daemon_user = cfg.daemon_user.value_or(defaults::DAEMON_USER);
      auto daemon_group = cfg.daemon_group.value_or(defaults::DAEMON_GROUP);
      auto dropped = [&cfg, daemon_user, daemon_group]{
                       using microhttpd::sys::drop_privileges;  // NOT using tunitas::app::drop(...) which does basically the same thing, sortof.
                       if (cfg.daemon_group) {
                         if (UNIMPLEMENTED_TWO_ARGUMENT_DROP_PRIVILEGES_USER_GROUP) {
                           warning(cfg) << "the daemon group will be ignored  [[FIXTHAT]] in --daemon-group=" << q(*cfg.daemon_group) << '\n';
                           notice(cfg) << "only daemon user concept is implemented\n";
                           notice(cfg) << "acting as if only --daemon-user=" << q(daemon_user) << '\n';
                         }
                         return drop_privileges(daemon_user /*daemon_group*/); // [[FIXTHIS]] ... when available call drop_privileges(daemon_user, daemon_group);
                       } else {
                         return drop_privileges(daemon_user);
                       }
                     }();
      if (fail(dropped)) {
        if (!cfg.daemon_group || UNIMPLEMENTED_TWO_ARGUMENT_DROP_PRIVILEGES_USER_GROUP) {
          error(cfg) << "could not drop privileges to " << q(daemon_user) << '\n';
        } else {
          error(cfg) << "could not drop privileges to " << q(daemon_user) << '.' << q(daemon_group) << '\n';
        }
        throw exception::Quitting{cfg.NAME, FAIL};
      }
    }
    auto engine = [&cfg]() {
                    auto storage_name = cfg.storage_engine.value_or(defaults::STORAGE_ENGINE);
                    debug(cfg) << "engine=" << storage_name << '\n';
                    auto ordered = storage::factory().order(storage_name);
                    auto const could_not = [&cfg, &storage_name](char const *verb, std::error_code ec) {
                                             error(cfg)<< "could not " << verb << " storage engine '" << q(storage_name) << "' because " << ec.message() << '\n';
                                             throw exception::Quitting{cfg.NAME, sys::exits::UNAVAILABLE};
                                           };
                    if (!ok(ordered)) {
                      could_not("acquire", error_code(ordered));
                    }
                    auto builder = value(std::move(ordered));
                    storage::Configuration configuration; // [[FIXTHIS]] load up some configuration values from service::Configuration
                    auto built = builder->build(configuration);
                    if (!ok(built)) {
                      could_not("build", error_code(ordered));
                    }
                    return value(std::move(built));
                  }();

    try {
      Pidfile pidfile{cfg.pid_filepath, cfg.emit_pid.value_or(defaults::EMIT_PID)};
      pidfile.manual();
      auto foreground_mode = cfg.foreground_mode.value_or(defaults::FOREGROUND_MODE);
      debug(cfg) << "foreground mode = " << std::boolalpha << foreground_mode << '\n';
      if (!foreground_mode) {
        auto ized = daemon(CHDIR, CLOSE);
        if (!ok(ized)) {
          error(cfg) << "could not daemonize because " << error_code(ized).message() << '\n';
          throw exception::Quitting{cfg.NAME, sys::exits::FAIL};
        }
      }
      pidfile.emit();
      pidfile.close();
    } catch (tunitas::app::exception::Aspect const &e) {
      throw;
    } catch (std::exception const &e) {
      error(cfg) << "failed to write the pid file " << cfg.pid_filepath.value_or("stderr") << " because " << e.what() << '\n';
      throw exception::Quitting{cfg.NAME, sys::exits::FAIL};
    }
#if 1 // [[REMOVEWHEN]] we're clear that the above does the below
    [&service, &target=*engine->consent]{
      service.router.enregister("/consent"s, std::make_shared<endpoint::Consent>(target));
      service.router.enregister("/consent/createWithArray"s, std::make_shared<endpoint::Consent_CreateWithArray>(target));
      service.router.enregister("/consent/createWithList"s, std::make_shared<endpoint::Consent_CreateWithList>(target));
      [&service, resource=std::make_shared<endpoint::Consent_FindIdentifiersByEntity>(target)]{
        service.router.enregister("/consent/findIdentifiersByEntity"s, resource);
        service.router.enregister("/consent/findIdsByEntity"s, resource);
      }();
      service.router.enregister("/consent/{consentId}"s, std::make_shared<endpoint::Consent_Identifier>(target));
      service.router.enregister("/consent/revokeWithArray"s, std::make_shared<endpoint::Consent_RevokeWithArray>(target));
      service.router.enregister("/consent/revokeWithList"s, std::make_shared<endpoint::Consent_RevokeWithList>(target));
      service.router.enregister("/consent/revoke/{consentId}"s, std::make_shared<endpoint::Consent_Revoke_Identifier>(target));
    }();
    [&service, &target=*engine->transfer]{
      service.router.enregister("/datatransfer"s, std::make_shared<endpoint::Transfer>(target));
      service.router.enregister("/datatransfer/createWithArray"s, std::make_shared<endpoint::Transfer_CreateWithArray>(target));
      service.router.enregister("/datatransfer/createWithList"s, std::make_shared<endpoint::Transfer_CreateWithList>(target));
      [&service, resource=std::make_shared<endpoint::Transfer_FindByConsentIdentifier>(target)]{
        service.router.enregister("/datatransfer/findByConsentIdentifier"s, resource);
        service.router.enregister("/datatransfer/findByConsentID"s, resource);
        service.router.enregister("/datatransfer/findByConsentId"s, resource);
      }();
      service.router.enregister("/datatransfer/{datatransferId}"s, std::make_shared<endpoint::Transfer_Identifier>(target));
    }();
    [&service, &target=*engine->subscription]{
      service.router.enregister("/subscription"s, std::make_shared<endpoint::Subscription>(target));
      service.router.enregister("/subscription/findByEntity"s, std::make_shared<endpoint::Subscription_FindByEntity>(target));
      service.router.enregister("/subscription/{subscriptionId}"s, std::make_shared<endpoint::Subscription_Identifier>(target));
    }();
#else
    auto const FAMILY_URL_SENSE = false;
    endpoint::Consent consent{*engine->consent};
    service.register_resource("/consent", &consent, FAMILY_URL_SENSE);

    endpoint::Consent_CreateWithArray consent_createWithArray{*engine->consent};
    service.register_resource("/consent/createWithArray", &consent_createWithArray, FAMILY_URL_SENSE);

    endpoint::Consent_CreateWithList consent_createWithList{*engine->consent};
    service.register_resource("/consent/createWithList", &consent_createWithList, FAMILY_URL_SENSE);

    endpoint::Consent_FindIdentifiersByEntity consent_findIdentifiersByEntity{*engine->consent};
    service.register_resource("/consent/findIdentifiersByEntity", &consent_findIdentifiersByEntity, FAMILY_URL_SENSE);
    // the pesky aliases
    service.register_resource("/consent/findIdsByEntity", &consent_findIdentifiersByEntity, FAMILY_URL_SENSE);

    endpoint::Consent_Identifier consent_identifier{*engine->consent};
    service.register_resource("/consent/{consentId}", &consent_identifier, FAMILY_URL_SENSE);

    endpoint::Consent_RevokeWithArray consent_revokeWithArray{*engine->consent};
    service.register_resource("/consent/revokeWithArray", &consent_revokeWithArray, FAMILY_URL_SENSE);

    endpoint::Consent_RevokeWithList consent_revokeWithList{*engine->consent};
    service.register_resource("/consent/revokeWithList", &consent_revokeWithList, FAMILY_URL_SENSE);

    endpoint::Consent_Revoke_Identifier consent_revoke_identifier{*engine->consent};
    service.register_resource("/consent/revoke/{consentId}", &consent_revoke_identifier, FAMILY_URL_SENSE);

    endpoint::Transfer transfer{*engine->transfer};
    service.register_resource("/datatransfer", &transfer, FAMILY_URL_SENSE);

    endpoint::Transfer_CreateWithArray transfer_createWithArray{*engine->transfer};
    service.register_resource("/datatransfer/createWithArray", &transfer_createWithArray, FAMILY_URL_SENSE);

    endpoint::Transfer_CreateWithList transfer_createWithList{*engine->transfer};
    service.register_resource("/datatransfer/createWithList", &transfer_createWithList, FAMILY_URL_SENSE);

    endpoint::Transfer_FindByConsentIdentifier transfer_findByConsentIdentifier{*engine->transfer};
    service.register_resource("/datatransfer/findByConsentIdentifier", &transfer_findByConsentIdentifier, FAMILY_URL_SENSE);
    // the pesky aliases
    service.register_resource("/datatransfer/findByConsentID", &transfer_findByConsentIdentifier, FAMILY_URL_SENSE);
    service.register_resource("/datatransfer/findByConsentId", &transfer_findByConsentIdentifier, FAMILY_URL_SENSE);

    endpoint::Transfer_Identifier transfer_identifier{*engine->transfer};
    service.register_resource("/datatransfer/{datatransferId}", &transfer_identifier, FAMILY_URL_SENSE);
  
    endpoint::Subscription subscription{*engine->subscription};
    service.register_resource("/subscription", &subscription, FAMILY_URL_SENSE);

    endpoint::Subscription_FindByEntity subscription_findByEntity{*engine->subscription};
    service.register_resource("/subscription/findByEntity", &subscription_findByEntity, FAMILY_URL_SENSE);

    endpoint::Subscription_Identifier subscription_identifier{*engine->subscription};
    service.register_resource("/subscription/{subscriptionId}", &subscription_identifier, FAMILY_URL_SENSE);

    // There is no 'quit' method.  The service runs forever.
    // To stop it, you have to kill it, e.g., systemctl stop montara
    service.start(constants::server::BLOCKING);
#endif  
    // There is no 'quit' method.  The service runs forever.
    // To stop it, you have to kill it, e.g., systemctl stop montara
    auto complain = [&cfg](microhttpd::Success result, microhttpd::string::Sequencez verb) {
                      auto ec = error_code(result);
                      error(cfg) << "could not " << verb << " the service because " << ec.message() << '\n';
                      notice(cfg) << "this unexpected, the error code will only provide a rudimentary explanation\n"; // good luck.
                      throw exception::Quitting{cfg.NAME, FAIL};
                    };
    if (auto launched = service.launch(); !good(launched)) {
      return complain(launched, "launch");
    }
    std::cerr << "run...\n";
    service.run();
    std::cerr << "wait...\n";
    service.wait();
    std::cerr << "stop...\n";
    service.stop();
    // If the wait returns then it means that the server is gracefully quitting..  Go with it.
  }
}
#endiv
